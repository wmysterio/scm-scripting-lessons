# 00085. Работа с битами переменных

Работа с битами переменных|Если вы изучали "Программирование" или "Основы цифровой техники", то эту тему вам без труда понять. Если же нет - будем сейчас изучать.|wmysterio|wmysterio||||Начнём с того, что каждая переменная состоит из битов. Бит - значение, которое может принимать значение 0 или 1. Их совокупность формирует какую-то информацию ( например: целое число ). Остановимся сы как раз на целых числах. Каждая переменная этого типа может иметь 32 бита. Пример: число 62 - это тоже самое, что и комбинация битов 111110, но это число не стоит воспринимать как десятичное. Здесь 111110 записано в двоичной системе числения, которые, как известно, состоит из ряда двух чисел - 0 или 1. В зависимости от порядка их размещения мы получаем разные результаты. Например: если мы поменяем последние цифры местами ( 111101 ) то результат будет - 61.

Как же собственно перевести число в двоичную систему числения? Хороший вопрос. Всё довольно просто. Нужно десятичное ( обычное для нас ) число постоянно делить на число 2 нацело. После чего в остатке в нас всегда будет число 0 или 1. Результат делим опять на 2 и так до тех пор, пока делить уже будет невозможно. В результате мы берём все остатки ( должен получится список чисел 0 и 1 ). После этого запишем это число в обратном направлении. Тоесть если мы получили комбинацию 011011, то результатом будет комбинация - 110110. Чтобы было понятнее, посмотрите картинку:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/23691172.png)

Как видите число 75 делили на 2. В нас вышло число 37, так как делить нужно на цело ( без дробной части ). 37\*2 даёт 74. В результате вычитания мы получаем число комбинации - 1. Если вы тестируете и результат вышел более чем 1, то вы допустили ошибку. Затем результат ( 37 ) мы снова делим на 2 и результатам будет 18, а остаток 1. Мы получаем вторую цифру комбинации и в результате комбинация будет иметь вид - 11. Так по-аналогии вычисляем комбинации. Когда в результате деления будет число 1, то известно, что его поделить нацело на 2 нельзя, поэтому он перемещается автоматически в комбинацию битов. Собственно мы её получили - 1101001. Теперь нам осталось поменять местами эту комбинацию в обратную сторону ( смотрите вторую строку и по цвету увидите как нужно перемещать ). Мы получим комбинацию - 1001011. Это наше число 75 в двоичной системе числения. Не верите? Сделаем эксперимент!

Запустите калькулятор на вашем ПК. Выберите пункт "Вид->Программист".

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/59363386.png)

Выберите "8 байт" на панели и установите чекбокс на "BIN". Теперь для ввода цифр в нас доступно только цифры 0 и 1:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/39305871.png)

Введите нашу битовою комбинацию:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/14749138.png)

Изменим чекбокс с "Bin" на "Dec" и что мы видим?

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/20373833.png)

Всё верно! Комбинация битов в результате вычисления на калькуляторе совпало с нашим числом - 75!

Теперь расскажу о порядке битов. Комбинация 1001011 состоит из 7 битов ( так, как там 7 чисел ). Каждый их них имеет свой порядковый номер, который начинается с нуля ( нулевой бит ). Максимальный же - 31-й бит. Можно сформировать таблицу битов:

| Номер бита    | Числовое значение   |
| ------------- | ------------------- |
| 0             | 1                   |
| 1             | 1                   |
| 2             | 0                   |
| 3             | 1                   |
| 4             | 0                   |
| 5             | 0                   |
| 6             | 1                   |
| К-во битов: 7 | Комбинация: 1001011 |

Можно сделать вывод, что биты читаются справа налево. Естественно, для подобных случаев пользуйтесь калькулятором для переводов. Я здесь расписал для того, что бы вы поняли откуда всё берётся :)

Собственно, зачем всё это нужно? Очень даже нужно! Например: при редактировании игровой памяти, где во многих случаях нужно будет изменять значения, которые изменяются только по битам.

Рассмотрим опкоды:

```
08BA: set 0@ bit 1
```

Задать переменной бит в числовое значение 1.

Здесь:\
0@ - нужная переменная\
1 - номер бита ( см. таблицу выше )

```
08C0: clear 0@ bit 1
```

Задать переменной бит в числовое значение 0 ( очищает бит от значения 1 ).

Здесь:\
0@ - нужная переменная\
1 - номер бита ( см. таблицу выше )

Так же можно проверить "Бит переменной равен 1?":

```
08B4: test 0@ bit 1
```

Здесь:\
0@ - нужная переменная\
1 - номер бита ( см. таблицу выше )

Обратите внимание, что проверять можно только на единицу. Для того, что бы проверить "Бит переменной равен 0?" нужно:

```
88B4: not test 0@ bit 1
```

Пример "Переодевания" я взял со справки, так как сейчас нет времени делать:

```
create_thread @TEST1

 :TEST1
 thread 'TEST1'
 $391 = 0 // integer values

 :TEST1_18
 wait 0
 if
 00E1: key_pressed 0 8 //Group CTRL Forward
 jf @TEST1_46
 08BA: set $391 bit 0
 jump @TEST1_102

 :TEST1_46
 wait 0
 if
 00E1: key_pressed 0 9 //Group CTRL back
 jf @TEST1_74
 08BA: set $391 bit 1
 jump @TEST1_102

 :TEST1_74
 wait 0
 if
 00E1: key_pressed 0 10 //conversation - no
 jf @TEST1_102
 08BA: set $391 bit 2

 :TEST1_102
 wait 0
 if
 08B4: test $391 bit 0 // проверяем равен ли нулевой bit единице
 jf @TEST1_235 //если нет то переходим на следующую метку
 Player.SetClothes($PLAYER_CHAR, "PLAYER_TORSO", "TORSO", Torso)
 Player.SetClothes($PLAYER_CHAR, "AFRO", "AFRO", Head)
 Player.SetClothes($PLAYER_CHAR, "BBSHORTRED", "BOXINGSHORT", Legs)
 Player.SetClothes($PLAYER_CHAR, "COWBOYBOOT2", "BIKER", Shoes)
 Player.Build($PLAYER_CHAR)
 0110: clear_player $PLAYER_CHAR wanted_level
 //А это делаем, для того, чтобы копы игрока не доставали после переодевания
 jump @TEST1_510

 :TEST1_235
 wait 0
 if
 08B4: test $391 bit 1
 jf @TEST1_372
 Player.SetClothes($PLAYER_CHAR, "BBJERSEY", "SLEEVT", Torso)
 Player.SetClothes($PLAYER_CHAR, "GROOVECUT", "GROOVECUT", Head)
 Player.SetClothes($PLAYER_CHAR, "SUIT1TRGANG", "SUIT1TR", Legs)
 Player.SetClothes($PLAYER_CHAR, "SHOEDRESSBRN", "SHOE", Shoes)
 Player.Build($PLAYER_CHAR)
 0110: clear_player $PLAYER_CHAR wanted_level
 jump @TEST1_510

 :TEST1_372
 wait 0
 if
 08B4: test $391 bit 2
 jf @TEST1_510
 Player.SetClothes($PLAYER_CHAR, "TSHIRTERISYELL", "TSHIRT", Torso)
 Player.SetClothes($PLAYER_CHAR, "WEDGE", "WEDGE", Head)
 Player.SetClothes($PLAYER_CHAR, "BBSHORTWHT", "BOXINGSHORT", Legs)
 Player.SetClothes($PLAYER_CHAR, "FLIPFLOP", "FLIPFLOP", Shoes)
 Player.Build($PLAYER_CHAR)
 0110: clear_player $PLAYER_CHAR wanted_level

 :TEST1_510
 08C0: clear $391 bit 0
 08C0: clear $391 bit 1
 08C0: clear $391 bit 2
 jump @TEST1_18
```

Будет время, покажу вам как сделать вот такую вот ветку талантов, из моего скрипта Warlock:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/1/32440651.png)|919|1|0|23691172\`png\`453\`285\`400\`251\`\`\\|59363386\`png\`419\`383\`399\`365\`\`\\|39305871\`png\`417\`380\`400\`364\`\`\\|14749138\`png\`407\`67\`400\`65\`\`\\|20373833\`png\`419\`383\`399\`365\`\`\\|32440651\`png\`500\`300\`400\`240\`\`\\||rabota\_s\_bitami\_peremennykh|1499848405
