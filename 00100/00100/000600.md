---
description: >-
  В этой статье мы рассмотрим фундаментальное понятие переменной и операции,
  которые можно с ними провернуть.
---

# Переменные. Операторы

Основополагающей составляющей скриптинга SCM и программирования в целом являются переменные. Очень важно рассмотреть эту статью, так как без базовых знаний этой темы дальнейшее развитие навыков теряет смысл. Поэтому начнём!

А начнём мы, как и обычно, из определения. Переменная — это некий контейнер (область в памяти), где сохраняются данные. Это её главная функция — **хранение**. Эти данные можно получить или перезаписать в зависимости от ситуации. Возможность перезаписи данных оправдывают название контейнера, так как данные не фиксированы.

Для чтения и записи нужны инструменты. В первую очередь нужно знать как обращаться к данным. Для этого существуют особые формы записи. Эти формы имеют особый контекст и разделяются на две категории:

* Локальные
* Глобальные

Контекст определяет область применения этих переменных. В CLEO-скриптах подавляющие количество переменных являются локальными, потому начнём детальный разбор именно из них!

### Локальные переменные

Само название говорит, что такие переменные используются локально. Другими словами на них накладываются ограничения: все локальные переменные могут использоваться только в границах **текущего скрипта**! Каждый скрипт имеет собственный набор локальных переменных и нет возможности напрямую влиять на значения таких переменных в других скриптах. Это является как преимуществом, так и недостатком. К последнему можно отнести тот факт, что количество локальных переменных строго ограничено и нужно с умом использовать всю доступную область.

Синтаксис локальных переменных не славится читаемостью:

| Пример | Предназначение                                                              |
| ------ | --------------------------------------------------------------------------- |
| `0@`   | Хранение любых чисел                                                        |
| `0@s`  | Хранение коротких строк до 7 символов<mark style="color:red;">**\***</mark> |
| `0@v`  | Хранение длинных строк до 15 символов<mark style="color:red;">**\***</mark> |

Сначала пишется числовой идентификатор (номер переменной); далее особый символ-маркер `@` для компилятора; и суффикс<mark style="color:red;">**\***</mark>, тоже для компилятора.

{% hint style="danger" %}
<mark style="color:red;">**\***</mark> Только для GTA San Andreas!
{% endhint %}

Номера переменных имеют следующие ограничения:

| III    | VC     | SA                                                        |
| ------ | ------ | --------------------------------------------------------- |
| `0-15` | `0-15` | `0-31`                                                    |
|        |        | `0-31`, `34-1023`<mark style="color:red;">**\*\***</mark> |

{% hint style="danger" %}
<mark style="color:red;">**\*\***</mark> Только в режиме миссии!
{% endhint %}

Я специально дал именно такой диапазон, поскольку в них можно гарантированно сохранить данные. Но есть особые локальные переменные, которые «слишком переменные», то есть у нас нет способа обеспечить их постоянность. Связано это с механикой их работы, описанной ниже.

#### Локальные переменные-таймеры скрипта

Каждый скрипт имеет два так называемых таймера скрипта. Они постепенно увеличивают своё значение на время, затраченное на ожидание. Они не привязаны к реальному времени. По крайней мере их значения не совпадали с моими ожиданиями, хоть и были достаточно похожими вначале тестов. Номера этих переменных написаны в таблице ниже:

| III     | VC      | SA      |
| ------- | ------- | ------- |
| `16-17` | `16-17` | `32-33` |

К счастью запоминать конкретно эти значения нам не нужно. Современный Sanny Builder предоставляет готовые [константы](https://docs.sannybuilder.com/v/ru/coding/variables#peremennye-taimery), которые автоматически будут ссылаться на нужные таймеры в зависимости от выбранной игры. Их имена: `TIMERA` и `TIMERB`. Мы ещё вернёмся к ним в других статьях, где будет их явная роль. Пока только запомните эту информацию.

### Хранение строк в локальных переменных

Скриптинг **GTA SA** даёт нам больше гибкости в плане хранения данных, позволяя записывать строки в переменные. Если с числами нет особых заморочек, то вот строки требуют более детального разбора.



Для каждого типа строки есть свой тип переменной. Короткие строки помечены суффиксом `s`, а длинные строки — `v`.



Поскольку строки требуют больше места для хранения — в отличии от чисел — то и&#x20;



В скриптинге **GTA SA** есть особые типы переменных, предназначенных для хранения строк. Они помеченные суффиксами `s` (короткая строка) и `v` (длинная строка). Отличаются они в первую очередь размером



В отличии от переменных для чисел, они требуют больше места для хранения. &#x20;

Это значит, что строки требуют больше переменных ввиду специфики их хранения. Для короткой s-строки используются сразу две переменные: та, что объявлена под номером и одна следующая. Для v-строк используется тот же принцип, только количество переменных для хранения больше ещё на две штуки. В целом всё это можно представить так:

|       |  Запись                                                                                                                                                               |          Строка |
| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------: |
| `1@s` | <p><code>1@</code>=<code>'DEMO'</code></p><p><code>2@</code>=<code>'STR'</code></p>                                                                                   |       `DEMOSTR` |
| `4@v` | <p><code>4@</code>=<code>'STRI'</code></p><p><code>5@</code>=<code>'NGEX'</code></p><p><code>6@</code>=<code>'AMPL'</code></p><p><code>7@</code>=<code>'E'</code></p> | `STRINGEXAMPLE` |



Хоть в колонке "Запись" и показан пример записи строки, фактически происходит её кодирование в числовой вид. Это позволяет запись её в одну переменную.&#x20;

&#x20;когда условные строки кодируются в числовой вид, что позволяет записать их в одну переменную. В качестве вывода можем констатировать, что хоть синтаксически используется одна переменная, изнутри





Редактирование main.scm. Переменные (Часть 2)|В этом уроке речь идёт о локальных и глобальных переменных, и о том, как они используются в потоках.|wmysterio|wmysterio||||В предыдущем уроке мы рассмотрели как создавать глобальные переменные. Такой формат позволяет нам Sanny Builder ( чем мы собственно воспользовались ). Однако сами переменные в конечном итоге будут записаны как:

$ИНДЕКС

Если мы задаём имя не числом, то компилятор автоматически подбирает свободный индекс в общем массиве глобальных переменных. Таким образом глобальная переменная получает синоним, который ввёл скриптер.

Некоторые синонимы уже зарезервированны компилятором и записывать на их место значения отличных от их первоначальных целей не рекомендовано. Давайте рассмотрим глобальные переменные, которые не рекомендовано перезаписывать:

| Индексная переменная | Синоним        | Описание                                                       |
| -------------------- | -------------- | -------------------------------------------------------------- |
|                      |                |                                                                |
| $2                   | $PLAYER\_CHAR  | Переменная, которая хранит ссылку на игрока                    |
|                      |                |                                                                |
| $3                   | $PLAYER\_ACTOR | Переменная, которая хранит ссылку персонажа игрока             |
|                      |                |                                                                |
| $11                  | $PLAYER\_GROUP | Переменная, которая хранит ссылку на группу (банды) игрока     |
|                      |                |                                                                |
| $409                 | $ONMISSON      | Переменная, которая хранит флаг миссии (1 - включена, 0 - нет) |
|                      |                |                                                                |

В предыдущих уроках я уже публиковал код мейна, где уже использовались эти переменные и они были заданы необходимыми значениями, так что о них волноваться по этому поводу не нужно - главное не записывайте значения в эти переменные вне потока "MAIN". Это нужно хотя бы для того, чтобы CLEO-скрипты других разработчиков могли полноценно работать.

Кроме тех типов данных, которые были в предыдущем уроке, существуют ещё ссылки ( указатели или хэндлы ). Они ссылаются на какие-то сущности, которые были созданы в игре скриптами. В меременные записывается число, которое является адресом где-то там в памяти. Но сейчас нас это не должно волновать - позже всё станет ясно. Вот пример некоторых сущностей, которые можно хранить в переменных:

| ACTOR  | Актёр - это любой персонаж в игре: полицейский, байкер, шлюха и т.п.                                                 |
| ------ | -------------------------------------------------------------------------------------------------------------------- |
|        |                                                                                                                      |
| CAR    | Транспорт - это средство передвижения в игре: лодка, байк, велик, машина и т.п.                                      |
|        |                                                                                                                      |
| OBJECT | Объект - это дома, бочки, дороги, двери. В общем сложно объяснить, что это. Скажем — мелкие или большие детали игры. |
|        |                                                                                                                      |

Эти и остальные хэндлы мы изучим в следующих уроках и более детально изучим их. Я хотел просто показать что может хранится в переменных.

Рассмотрим также использование локальных переменных в потоках. Всё, о чём я сейчас расскажу очень важно в скриптинге. Создадим 2 потока: ":A" и ":B":

```
// ...
create_thread @A
create_thread @B
end_thread

:A
thread 'A'
wait 0
0@ = 0
jump @A

:B
thread 'B'
wait 0
0@ = 1
jump @B
```

Вопрос: что будет хранится в переменной 0@? 1? 0? Не правильно! В переменной 0@ будут хранится оба числа! Почему так? Потому, что потоки в данном случае работают параллельно ( как бы одновременно ). Что бы вам объяснить, рассмотрим пример в реальной жизни:

Представим обычною городскую школу. Представим классы. Например: 11-й. Учеников много, поэтому их распределили на A, B, C. Вот возьмём имена учеников. Ученики будут нашими переменными:

```
0@ - Вася
1@ - Славик
2@ - Макс
3@ - Юра 
```

Они учатся в классе "11 A". В параллельном классе, то есть в "11 B", есть ученики с теми самими именами:

```
0@ - Вася
1@ - Славик
2@ - Макс
3@ - Юра 
```

Видим, что имена одинаковы, но не забываем, что характер, черты лица всегда разные, то есть каждый человек - индивидуальный. Так же само с переменными - имена одинаковы, но находятся они в разных потоках. Следовательно они могут изменятся только в пределах своего потока. Что это значит "своего потока"? Наш 1-й поток — это класс "11 A". Все ученики заперты в своём классе! ( Пусть этого не будет в реальной жизни :) ) В нём они творят то, что нам захочется. Как и ученити, так и переменные - заперты в потоке. Если вызывается 1-й поток командой "сreate\_thread", значит строится класс "11 A". Следовательно "end\_thread" — разрушает этот класс в месте с учениками и о них больше ни слова, ни духа, пока мы опять не построим класс ( станем вызывать тот же поток ).

Одновременно нельзя построить 2 одинаковых класса, то есть:

```
// ...
create_thread @A 
create_thread @A
end_thread
```

Вернее можно, но крайне не рекомендовано, так как это приводит к вылету игры. Такой вариант не правильный, потому что мы вызываем работающий поток, запущенный ранее. Об этом я вам уже рассказывал в предыдущих уроках.

Так же не забываем о игровых лимитах: в потоке может быть не больше 33 локальных переменных. То есть максимум в классе может быть 33 ученика с разными именами. Этого вполне достаточно для потока.

× \*\*Примечание:\*\* Все имена должны быль меньше числа 34.

Если написать так:

102@ = 1

то компилятор сообщит об ошибке: "Локальная переменная вне доступных границ"

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/0/84748247.png)

Так что пользуемся формулой:

от 0 до 33 + @

Это правило действует только на локальные переменные!

× \*\*ВАЖНО:\*\* Последние две перемененные - таймеры и они всегда меняют своё значение, поэтому для хранения данных они не подходят.

Поэтому лимит переменных будет ещё большим: от 0 до 31. О таймерах мы поговорим в следующих уроках.

Глобальные же переменные имеют больше возможностей. Они могут существовать и без активного потока и при этом сохранять какую то информацию, а в потоках - изменяться или влиять на что-то. Давайте рассмотрим пример использования глобальной переменной:

![](../../\_pu/0/97568642.png)

Как видим вначале переменная "$DIMA" была равна нулю. После создания потока "А", мы добавили к ней число "5". Легко догадаться, что в переменной "$DIMA" теперь будет число "5". Но особенностью глобальных переменных в том, что поток "B" будет знать о переменной "$DIMA", хоть она там и не использовалась.

Можно привести пример с реальной жизни. Тоже представим школу и классы. А $DIMA — - это директор. Во все классы он может зайти или выйти. Значит изменять или проверять переменную можно в любом месте скрипта. Значение переменной может быть любым, в зависимости от последней выполненной операции над ней. В нашем случаи поток будет знать, что в переменной $DIMA будет число 5.

В следующем уроке мы рассмотрим перемененные, которые могут иметь одинаковые имена.|1470|1|0|84748247`png`445`134`400`120``\|97568642`png`188`306

```
`\||redaktirovanie_main_scm_peremennye_chast_2|1498222439
```
