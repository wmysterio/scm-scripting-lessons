---
description: >-
  В этой статье мы рассмотрим фундаментальные понятия, которые так или иначе
  присутствуют в Sanny Builder.
---

# Типы данных. Литералы. Константы. Переменные

Начну статью о понятии `тип данных`. В своей сути тип являются некой категорией для множества значений; группировкой значений по категории (типу). Скриптинг SCM на даёт нам особой свободы в плане выбора, поэтому мы можем сразу определить доступные для скриптинга типы. Всего их два:

* Числа
* Строки

Эти типы в свою очередь делятся ещё на дополительные подтипы:

| Строки   | Пример                       |
| -------- | ---------------------------- |
| Короткая | `'STRING'`, `'HELLO'`        |
| Длинная  | `"MY_STRING"`, `"WMYSTERIO"` |

| Числа        | Пример                |
| ------------ | --------------------- |
| Целые        | `10`, `0`, `-100`     |
| Вещественные | `6.0`, `0.0`, `-20.5` |

| Другие    | Пример                 |
| --------- | ---------------------- |
| Булево    | `True`, `False`        |
| ID модели | `#ADMIRAL`, `#BUFFALO` |
| Метки     | `@LABEL`               |
| ...       | ...                    |

Таблица типов `Другие` являются скорее полезными или косметичными; и более привычными по содержанию для опытных программистов. Значения этих типов в конечном итоге превращаются в целые числа. Эта таблица может быть дополнена в будущем, но основная суть не изменится.

## Литералы

Колонки `Пример` демонстрируют способ расспознать или создать значение некого типа. Сами значения всегда являются фиксированными и неизменными для скриптера (ноль всегда будет нулём и т.п.). Для такой особой формы записи существует даже отдельный термин — **Литерал**; он же константа без имени.

## Константы

Начнём с определения. Константа — это некое фиксированное значение, которому присвоено имя. Это имя, как и его значение, не может быть изменённым после его объявления.

Константы помогают лучше контролировать часть кода. В основном из за того, что они используются непосредственно в коде один или множество раз, тогда как изменения значения константы происходит в одном месте.

Объявляются константы в блоке `const ... end`, а синтаксис заполнения такой:

```
ИмяКонстанты = Значение
```

Для примера давайте создадим простой блок с константой, которая будут символизировать количество денег:

```
const
    MONEY_VALUE = 100
end
```

Теперь когда SB будет компилировать код, то он автоматически заменит `MONEY_VALUE` на число `100`. Кроме числа туда можно записывать и другие литералы. Плюс есть возможность записать в качестве значения ещё и свойства [классов](000300.md#klassy):

```
MONEY = Player.Money($PLAYER_CHAR)
```

Конечно такую запись я никогда не использовал и не планирую, но могу только констатировать, что это возможно. Давайте лучше рассмотрим фрагмент кода простого скрипта с использованием констант:

```
const
    MONEY_VALUE = 100
    MONEY = Player.Money($PLAYER_CHAR)
end

MONEY += MONEY_VALUE
MONEY += MONEY_VALUE
```

В результате игроку дадут 200 баксов (дважды по 100). При компиляции `MONEY` будет заменён на `Player.Money($PLAYER_CHAR)` а `MONEY_VALUE` — на `100`, так что этот скрипт станет идентичным этому:

```
Player.Money($PLAYER_CHAR) += 100
Player.Money($PLAYER_CHAR) += 100
```

В примере кода константы могут показаться не целесообразными из за наличия дополнительного блока. Однако ценность существенно возрастает в более крупных проектах, где кода достаточно много и он постоянно разрастается.

{% hint style="success" %}
Константам лучше задавать запоминающиеся имена. Регистр может быть любым, но я рекомендую использовать название в верхнем регистре.
{% endhint %}

## Операции над числами

## Переменные

Автор: **wmysterio**

, которые присутствуют в скриптинге.

В этом уроке мы познакомимся с типами данных в SCM-скриптах и типами переменных. Также будут рассмотрены арифметические операции над числами.

Редактирование main.scm. Переменные (Часть 1)||wmysterio|wmysterio||||Вот так, понемножку, мы подошли к переменным. Что же это такое? Если образно представить, то можно сказать, что это ящик, в котором можно что то хранить. В потоках мы можем использовать много таких ящиков ( но не нужно забывать о лимитах ). Эти ящики называются **переменными**.

Так что же именно мы можем хранить? Давайте рассмотрим несколько типов данных:

| Тип данных | Пример                                 |                           |
| ---------- | -------------------------------------- | ------------------------- |
|            |                                        |                           |
| 1          | Целое число                            | 1, 0, -100                |
|            |                                        |                           |
| 2          | Дробное число                          | 6.0, 0.0, -20.5           |
|            |                                        |                           |
| 3          | Короткая строка ( максимум 7 символов) | 'STRING', 'HELLO'         |
|            |                                        |                           |
| 4          | Длинная строка ( максимум 15 символов) | "MY\_STRING", "RU-SCRIPT" |
|            |                                        |                           |

× \*\*Примечание:\*\* Все строки не имеют пробелов! В место них, как правило, пишется значок \*\*\_\*\*

Отличаются 3-й и 4-й тип тем, что они имеют свои ограничения по длине, в использовании, и пишутся они в разных скобках.

Естественно для этих типов есть свои правила, но запомнить нужно только то, что выполнять операции можно только между данными одинакового типа. Иначе результат будет неправильным. Кстати, насчёт операций... Давайте рассмотрим, что же можно делать с числами:

| Операция | Описание  |
| -------- | --------- |
|          |           |
| +=       | Сложение  |
|          |           |
| \*=      | Умножение |
|          |           |
| /=       | Деление   |
|          |           |
| -=       | Вычитание |
|          |           |

Приведу примеры этих операций:

| Правильно     | Не привильно |
| ------------- | ------------ |
|               |              |
| 2 += 2        | 22.5 += 7    |
|               |              |
| 0.25 \*= -0.1 | 5 \*= 3.4    |
|               |              |
| 220 /= 5      | 32.0 /= 4    |
|               |              |
| 33.3 -= 1.5   | 88 -= -55.5  |
|               |              |

× \*\*ВАЖНО:\*\* Делить на 0 и на 0.0 соответсвтенно нельзя!× \*\*ВАЖНО:\*\* Мы не можем выполнять арифметические операции между числами и строками, и наоборот - между строками и числами!

Вот, собственно, основные правила арифметических операций над числами. Правда записываются они в иной форме, так как что в место чисел слева у нас будут переменные! Думаю самое время рассказать о них.

Каждый человек имеет имя. Например, Ваня, Вася, Дима и т.п. Также имеют имена и наши переменные. Что бы создать переменную, нужно выполнить небольшую операцию: поставить знак доллара **$** и ввести имя.

× \*\*Примечание:\*\* Имена должны состоять только с латинских символов и не иметь пробелов! Допускаются ещё целые положительные числа и символ \*\*\_\*\*

Для примера, напишем несколько:

$WANYA\
$WASYA\
$DIMA

Итак, мы научились писать имена переменных. Их можно использовать во всём мейне и использовать во всех потоках. Такие переменные называю **глобальными**. Но есть и другие переменные, так званые - **локальные** - они тоже имеют имена, только, в отличии от глобальных, имена состоят только с положительных целых числел, а в конце имени стоит знак собаки электронной почты ( читается как "эт" ): **@**. Для примера, напишем несколько таких:

0@\
1@\
2@

Для строк синтаксис написания немного другой:

| Глобальные строки |                                                                                    |
| ----------------- | ---------------------------------------------------------------------------------- |
|                   |                                                                                    |
| v$WANYA           | Можно записать только строку с длинной в 15 символов, то есть с кавычкой \*\*"\*\* |
|                   |                                                                                    |
| s$WANYA           | Можно записать только строку с длинной в 7 символов, то есть с кавычкой \*\*'\*\*  |
|                   |                                                                                    |
| Локальные строки  |                                                                                    |
|                   |                                                                                    |
| 0@v               | Можно записать только строку с длинной в 15 символов, то есть с кавычкой \*\*"\*\* |
|                   |                                                                                    |
| 0@s               | Можно записать только строку с длинной в 7 символов, то есть с кавычкой \*\*'\*\*  |
|                   |                                                                                    |

Помните о ящиках? Так вот: всё куда то записывается! В нашем случае значение записываются в переменные ( образно - в ящики ). Давайте запишем число в переменную! Делается это так:

```
$WANYA = 2 // здесь операция = является записью числа 2 в переменную $WANYA
```

Мы записали в переменную "$WANYA" число 2. Правда не сложно? Давайте тогда умножим нашу переменную на число 3. Посмотрев операции над числами выше, напишем пример:

```
$WANYA *= 3 // умножаем переменную $WANYA на число 3
```

Следовательно, в переменной "$WANYA" теперь будет хранится число 6, так, как 2\*3=6. То есть, сначала идут арифметические операции, а результат сохраняется в той же переменной, стирая предыдущее значение. Напишем несколько таких операций:

```
$WANYA = 3
$WANYA *= 4
$WANYA /= 2
```

Не надо быть сильным в математике, что бы понять, что теперь в переменной "$WANYA" будет хранится число 6, хоть до операций в ней было число 3.

Но все те старания будут напрасны, если напишем следующее:

```
$WANYA = 3
$WANYA *= 4
$WANYA /= 2
$WANYA = 3
```

Почему напрасны? Потому что если написать так в скрипте, в "$WANYA" всё равно будет число 3 в независимости от выполненных ранее операций. Вот и особенность последовательности команд. Если всё же не поняли, приведу математический пример:

3 — 1-я операция - записываем число в переменную\
3\*4=12 — 2-я операция\
12/2=6 — 3-я операция\
3 — 4-я операция - записываем число в переменную

В общем основы с числовыми переменными думаю вы усвоили. Что же, давайте все арифметические операции перенесём в скрипт. Создадим поток с именем "MATEM" и напишем несколько операций в нём:

```
:MATEM
thread 'MATEM'
wait 0
$WASYA = 2
$WASYA += 4
$WASYA *= 3
$WASYA /= 9
$WASYA -= 2
end_thread
```

Ваша задача - посчитать, какое число будет в переменной "$WASYA" после завершения потока. Если у вас вышло число 0, то у вас огромный прогресс в операциях над переменными. Если всё же не вышло, попробуйте посчитать сначала. Это очень важно, так как мы учимся мыслить по-скриптерски.

Есть также операции, которые пишутся опкодами. Например, нужно переменную суммировать с другой переменной. Если написать так: "2@ += 3@" то появится ошибка:

Неверное выражение 2@ += 3@. Одна из переменных имеет неизвестный тип, либо их типы несовместимы.

В санни билдере невозможно выполнить данную операцию в таком виде. Для этого нужно воспользоваться опкодом! Пришло время применить фукнцию поиска опкодов! Для этого нажмите CTRL`+<kbd>ALT`+2\`. Должно появится окошко:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/0/02251412.png)

В поле "Искать" введите следующее:

@ += @

И вот мы видим наш список сократился во много раз:

![](../../\_pu/0/50360427.png)

Первые 2 опкода в списке - то, что искали. Осталось только определить тип данных, которых будет складывать. Оба типа должны совпадать! Если наши переменные - целые числа, то выделяем опкод, где есть комментарий "//(int)". Если наши переменные - дробные числа, то выделяем опкод, где есть комментарий "//(float)".

После этого жмём правую кн. мыши и жмём "Копировать":

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/0/55266821.png)

Закрываем окно, и вставляем его в редакторе:

![](https://github.com/wmysterio/scm-scripting-lessons/raw/resources/\_pu/0/26139132.png)

Есть и другой способ облегчить этот процесс, но о нём мы вернёмся чуть позже.

Вот мы и скопировали опкод, который нам был нужен. В нашем случаи опкод будет суммировать 2 дробных числа локальных переменных. Всё, что нам осталось - это переименовать переменные на нужные. Думаю с этим проблем не возникнет. Главное не перепутать с типами ;)

Искать "/", "\*", "-" можно по аналогии к примеру выше.

Данный пример действует только на локальные переменные. Что бы искал глобальные, то пишите в поиске это:

$ += $

Дальше всё по аналогии. Если нужно сделать операции, где нужно от глобальной переменной отнять локальную переменную, то в поиске введите:

$ -= @

Но не советую вам делать операции, где есть локальная и глобальная переменная без крайней необходимости. Лучше что бы обе были либо локальными, либо глобальными.|1849|1|0|02251412`png`788`673`400`341``\|50360427`png`358`209

```
`\|55266821`png`787`354`400`179``\|26139132`png`501`363`400`289``\||redaktirovanie_main_scm_peremennye_chast_1|1498216856
```
